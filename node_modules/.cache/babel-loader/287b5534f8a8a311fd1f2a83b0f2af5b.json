{"ast":null,"code":"var _ = require(\"underscore\");\n\nvar options = require(\"option\");\n\nvar results = require(\"./parsing-results\");\n\nvar errors = require(\"./errors\");\n\nvar lazyIterators = require(\"./lazy-iterators\");\n\nexports.token = function (tokenType, value) {\n  var matchValue = value !== undefined;\n  return function (input) {\n    var token = input.head();\n\n    if (token && token.name === tokenType && (!matchValue || token.value === value)) {\n      return results.success(token.value, input.tail(), token.source);\n    } else {\n      var expected = describeToken({\n        name: tokenType,\n        value: value\n      });\n      return describeTokenMismatch(input, expected);\n    }\n  };\n};\n\nexports.tokenOfType = function (tokenType) {\n  return exports.token(tokenType);\n};\n\nexports.firstOf = function (name, parsers) {\n  if (!_.isArray(parsers)) {\n    parsers = Array.prototype.slice.call(arguments, 1);\n  }\n\n  return function (input) {\n    return lazyIterators.fromArray(parsers).map(function (parser) {\n      return parser(input);\n    }).filter(function (result) {\n      return result.isSuccess() || result.isError();\n    }).first() || describeTokenMismatch(input, name);\n  };\n};\n\nexports.then = function (parser, func) {\n  return function (input) {\n    var result = parser(input);\n\n    if (!result.map) {\n      console.log(result);\n    }\n\n    return result.map(func);\n  };\n};\n\nexports.sequence = function () {\n  var parsers = Array.prototype.slice.call(arguments, 0);\n\n  var rule = function (input) {\n    var result = _.foldl(parsers, function (memo, parser) {\n      var result = memo.result;\n      var hasCut = memo.hasCut;\n\n      if (!result.isSuccess()) {\n        return {\n          result: result,\n          hasCut: hasCut\n        };\n      }\n\n      var subResult = parser(result.remaining());\n\n      if (subResult.isCut()) {\n        return {\n          result: result,\n          hasCut: true\n        };\n      } else if (subResult.isSuccess()) {\n        var values;\n\n        if (parser.isCaptured) {\n          values = result.value().withValue(parser, subResult.value());\n        } else {\n          values = result.value();\n        }\n\n        var remaining = subResult.remaining();\n        var source = input.to(remaining);\n        return {\n          result: results.success(values, remaining, source),\n          hasCut: hasCut\n        };\n      } else if (hasCut) {\n        return {\n          result: results.error(subResult.errors(), subResult.remaining()),\n          hasCut: hasCut\n        };\n      } else {\n        return {\n          result: subResult,\n          hasCut: hasCut\n        };\n      }\n    }, {\n      result: results.success(new SequenceValues(), input),\n      hasCut: false\n    }).result;\n\n    var source = input.to(result.remaining());\n    return result.map(function (values) {\n      return values.withValue(exports.sequence.source, source);\n    });\n  };\n\n  rule.head = function () {\n    var firstCapture = _.find(parsers, isCapturedRule);\n\n    return exports.then(rule, exports.sequence.extract(firstCapture));\n  };\n\n  rule.map = function (func) {\n    return exports.then(rule, function (result) {\n      return func.apply(this, result.toArray());\n    });\n  };\n\n  function isCapturedRule(subRule) {\n    return subRule.isCaptured;\n  }\n\n  return rule;\n};\n\nvar SequenceValues = function (values, valuesArray) {\n  this._values = values || {};\n  this._valuesArray = valuesArray || [];\n};\n\nSequenceValues.prototype.withValue = function (rule, value) {\n  if (rule.captureName && rule.captureName in this._values) {\n    throw new Error(\"Cannot add second value for capture \\\"\" + rule.captureName + \"\\\"\");\n  } else {\n    var newValues = _.clone(this._values);\n\n    newValues[rule.captureName] = value;\n\n    var newValuesArray = this._valuesArray.concat([value]);\n\n    return new SequenceValues(newValues, newValuesArray);\n  }\n};\n\nSequenceValues.prototype.get = function (rule) {\n  if (rule.captureName in this._values) {\n    return this._values[rule.captureName];\n  } else {\n    throw new Error(\"No value for capture \\\"\" + rule.captureName + \"\\\"\");\n  }\n};\n\nSequenceValues.prototype.toArray = function () {\n  return this._valuesArray;\n};\n\nexports.sequence.capture = function (rule, name) {\n  var captureRule = function () {\n    return rule.apply(this, arguments);\n  };\n\n  captureRule.captureName = name;\n  captureRule.isCaptured = true;\n  return captureRule;\n};\n\nexports.sequence.extract = function (rule) {\n  return function (result) {\n    return result.get(rule);\n  };\n};\n\nexports.sequence.applyValues = function (func) {\n  // TODO: check captureName doesn't conflict with source or other captures\n  var rules = Array.prototype.slice.call(arguments, 1);\n  return function (result) {\n    var values = rules.map(function (rule) {\n      return result.get(rule);\n    });\n    return func.apply(this, values);\n  };\n};\n\nexports.sequence.source = {\n  captureName: \"☃source☃\"\n};\n\nexports.sequence.cut = function () {\n  return function (input) {\n    return results.cut(input);\n  };\n};\n\nexports.optional = function (rule) {\n  return function (input) {\n    var result = rule(input);\n\n    if (result.isSuccess()) {\n      return result.map(options.some);\n    } else if (result.isFailure()) {\n      return results.success(options.none, input);\n    } else {\n      return result;\n    }\n  };\n};\n\nexports.zeroOrMoreWithSeparator = function (rule, separator) {\n  return repeatedWithSeparator(rule, separator, false);\n};\n\nexports.oneOrMoreWithSeparator = function (rule, separator) {\n  return repeatedWithSeparator(rule, separator, true);\n};\n\nvar zeroOrMore = exports.zeroOrMore = function (rule) {\n  return function (input) {\n    var values = [];\n    var result;\n\n    while ((result = rule(input)) && result.isSuccess()) {\n      input = result.remaining();\n      values.push(result.value());\n    }\n\n    if (result.isError()) {\n      return result;\n    } else {\n      return results.success(values, input);\n    }\n  };\n};\n\nexports.oneOrMore = function (rule) {\n  return exports.oneOrMoreWithSeparator(rule, noOpRule);\n};\n\nfunction noOpRule(input) {\n  return results.success(null, input);\n}\n\nvar repeatedWithSeparator = function (rule, separator, isOneOrMore) {\n  return function (input) {\n    var result = rule(input);\n\n    if (result.isSuccess()) {\n      var mainRule = exports.sequence.capture(rule, \"main\");\n      var remainingRule = zeroOrMore(exports.then(exports.sequence(separator, mainRule), exports.sequence.extract(mainRule)));\n      var remainingResult = remainingRule(result.remaining());\n      return results.success([result.value()].concat(remainingResult.value()), remainingResult.remaining());\n    } else if (isOneOrMore || result.isError()) {\n      return result;\n    } else {\n      return results.success([], input);\n    }\n  };\n};\n\nexports.leftAssociative = function (leftRule, rightRule, func) {\n  var rights;\n\n  if (func) {\n    rights = [{\n      func: func,\n      rule: rightRule\n    }];\n  } else {\n    rights = rightRule;\n  }\n\n  rights = rights.map(function (right) {\n    return exports.then(right.rule, function (rightValue) {\n      return function (leftValue, source) {\n        return right.func(leftValue, rightValue, source);\n      };\n    });\n  });\n  var repeatedRule = exports.firstOf.apply(null, [\"rules\"].concat(rights));\n  return function (input) {\n    var start = input;\n    var leftResult = leftRule(input);\n\n    if (!leftResult.isSuccess()) {\n      return leftResult;\n    }\n\n    var repeatedResult = repeatedRule(leftResult.remaining());\n\n    while (repeatedResult.isSuccess()) {\n      var remaining = repeatedResult.remaining();\n      var source = start.to(repeatedResult.remaining());\n      var right = repeatedResult.value();\n      leftResult = results.success(right(leftResult.value(), source), remaining, source);\n      repeatedResult = repeatedRule(leftResult.remaining());\n    }\n\n    if (repeatedResult.isError()) {\n      return repeatedResult;\n    }\n\n    return leftResult;\n  };\n};\n\nexports.leftAssociative.firstOf = function () {\n  return Array.prototype.slice.call(arguments, 0);\n};\n\nexports.nonConsuming = function (rule) {\n  return function (input) {\n    return rule(input).changeRemaining(input);\n  };\n};\n\nvar describeToken = function (token) {\n  if (token.value) {\n    return token.name + \" \\\"\" + token.value + \"\\\"\";\n  } else {\n    return token.name;\n  }\n};\n\nfunction describeTokenMismatch(input, expected) {\n  var error;\n  var token = input.head();\n\n  if (token) {\n    error = errors.error({\n      expected: expected,\n      actual: describeToken(token),\n      location: token.source\n    });\n  } else {\n    error = errors.error({\n      expected: expected,\n      actual: \"end of tokens\"\n    });\n  }\n\n  return results.failure([error], input);\n}","map":{"version":3,"names":["_","require","options","results","errors","lazyIterators","exports","token","tokenType","value","matchValue","undefined","input","head","name","success","tail","source","expected","describeToken","describeTokenMismatch","tokenOfType","firstOf","parsers","isArray","Array","prototype","slice","call","arguments","fromArray","map","parser","filter","result","isSuccess","isError","first","then","func","console","log","sequence","rule","foldl","memo","hasCut","subResult","remaining","isCut","values","isCaptured","withValue","to","error","SequenceValues","firstCapture","find","isCapturedRule","extract","apply","toArray","subRule","valuesArray","_values","_valuesArray","captureName","Error","newValues","clone","newValuesArray","concat","get","capture","captureRule","applyValues","rules","cut","optional","some","isFailure","none","zeroOrMoreWithSeparator","separator","repeatedWithSeparator","oneOrMoreWithSeparator","zeroOrMore","push","oneOrMore","noOpRule","isOneOrMore","mainRule","remainingRule","remainingResult","leftAssociative","leftRule","rightRule","rights","right","rightValue","leftValue","repeatedRule","start","leftResult","repeatedResult","nonConsuming","changeRemaining","actual","location","failure"],"sources":["E:/react-projects/new project/2022/converter/converter/node_modules/lop/lib/rules.js"],"sourcesContent":["var _ = require(\"underscore\");\nvar options = require(\"option\");\nvar results = require(\"./parsing-results\");\nvar errors = require(\"./errors\");\nvar lazyIterators = require(\"./lazy-iterators\");\n\nexports.token = function(tokenType, value) {\n    var matchValue = value !== undefined;\n    return function(input) {\n        var token = input.head();\n        if (token && token.name === tokenType && (!matchValue || token.value === value)) {\n            return results.success(token.value, input.tail(), token.source);\n        } else {\n            var expected = describeToken({name: tokenType, value: value});\n            return describeTokenMismatch(input, expected);\n        }\n    };\n};\n\nexports.tokenOfType = function(tokenType) {\n    return exports.token(tokenType);\n};\n\nexports.firstOf = function(name, parsers) {\n    if (!_.isArray(parsers)) {\n        parsers = Array.prototype.slice.call(arguments, 1);\n    }\n    return function(input) {\n        return lazyIterators\n            .fromArray(parsers)\n            .map(function(parser) {\n                return parser(input);\n            })\n            .filter(function(result) {\n                return result.isSuccess() || result.isError();\n            })\n            .first() || describeTokenMismatch(input, name);\n    };\n};\n\nexports.then = function(parser, func) {\n    return function(input) {\n        var result = parser(input);\n        if (!result.map) {\n            console.log(result);\n        }\n        return result.map(func);\n    };\n};\n\nexports.sequence = function() {\n    var parsers = Array.prototype.slice.call(arguments, 0);\n    var rule = function(input) {\n        var result = _.foldl(parsers, function(memo, parser) {\n            var result = memo.result;\n            var hasCut = memo.hasCut;\n            if (!result.isSuccess()) {\n                return {result: result, hasCut: hasCut};\n            }\n            var subResult = parser(result.remaining());\n            if (subResult.isCut()) {\n                return {result: result, hasCut: true};\n            } else if (subResult.isSuccess()) {\n                var values;\n                if (parser.isCaptured) {\n                    values = result.value().withValue(parser, subResult.value());\n                } else {\n                    values = result.value();\n                }\n                var remaining = subResult.remaining();\n                var source = input.to(remaining);\n                return {\n                    result: results.success(values, remaining, source),\n                    hasCut: hasCut\n                };\n            } else if (hasCut) {\n                return {result: results.error(subResult.errors(), subResult.remaining()), hasCut: hasCut};\n            } else {\n                return {result: subResult, hasCut: hasCut};\n            }\n        }, {result: results.success(new SequenceValues(), input), hasCut: false}).result;\n        var source = input.to(result.remaining());\n        return result.map(function(values) {\n            return values.withValue(exports.sequence.source, source);\n        });\n    };\n    rule.head = function() {\n        var firstCapture = _.find(parsers, isCapturedRule);\n        return exports.then(\n            rule,\n            exports.sequence.extract(firstCapture)\n        );\n    };\n    rule.map = function(func) {\n        return exports.then(\n            rule,\n            function(result) {\n                return func.apply(this, result.toArray());\n            }\n        );\n    };\n    \n    function isCapturedRule(subRule) {\n        return subRule.isCaptured;\n    }\n    \n    return rule;\n};\n\nvar SequenceValues = function(values, valuesArray) {\n    this._values = values || {};\n    this._valuesArray = valuesArray || [];\n};\n\nSequenceValues.prototype.withValue = function(rule, value) {\n    if (rule.captureName && rule.captureName in this._values) {\n        throw new Error(\"Cannot add second value for capture \\\"\" + rule.captureName + \"\\\"\");\n    } else {\n        var newValues = _.clone(this._values);\n        newValues[rule.captureName] = value;\n        var newValuesArray = this._valuesArray.concat([value]);\n        return new SequenceValues(newValues, newValuesArray);\n    }\n};\n\nSequenceValues.prototype.get = function(rule) {\n    if (rule.captureName in this._values) {\n        return this._values[rule.captureName];\n    } else {\n        throw new Error(\"No value for capture \\\"\" + rule.captureName + \"\\\"\");\n    }\n};\n\nSequenceValues.prototype.toArray = function() {\n    return this._valuesArray;\n};\n\nexports.sequence.capture = function(rule, name) {\n    var captureRule = function() {\n        return rule.apply(this, arguments);\n    };\n    captureRule.captureName = name;\n    captureRule.isCaptured = true;\n    return captureRule;\n};\n\nexports.sequence.extract = function(rule) {\n    return function(result) {\n        return result.get(rule);\n    };\n};\n\nexports.sequence.applyValues = function(func) {\n    // TODO: check captureName doesn't conflict with source or other captures\n    var rules = Array.prototype.slice.call(arguments, 1);\n    return function(result) {\n        var values = rules.map(function(rule) {\n            return result.get(rule);\n        });\n        return func.apply(this, values);\n    };\n};\n\nexports.sequence.source = {\n    captureName: \"☃source☃\"\n};\n\nexports.sequence.cut = function() {\n    return function(input) {\n        return results.cut(input);\n    };\n};\n\nexports.optional = function(rule) {\n    return function(input) {\n        var result = rule(input);\n        if (result.isSuccess()) {\n            return result.map(options.some);\n        } else if (result.isFailure()) {\n            return results.success(options.none, input);\n        } else {\n            return result;\n        }\n    };\n};\n\nexports.zeroOrMoreWithSeparator = function(rule, separator) {\n    return repeatedWithSeparator(rule, separator, false);\n};\n\nexports.oneOrMoreWithSeparator = function(rule, separator) {\n    return repeatedWithSeparator(rule, separator, true);\n};\n\nvar zeroOrMore = exports.zeroOrMore = function(rule) {\n    return function(input) {\n        var values = [];\n        var result;\n        while ((result = rule(input)) && result.isSuccess()) {\n            input = result.remaining();\n            values.push(result.value());\n        }\n        if (result.isError()) {\n            return result;\n        } else {\n            return results.success(values, input);\n        }\n    };\n};\n\nexports.oneOrMore = function(rule) {\n    return exports.oneOrMoreWithSeparator(rule, noOpRule);\n};\n\nfunction noOpRule(input) {\n    return results.success(null, input);\n}\n\nvar repeatedWithSeparator = function(rule, separator, isOneOrMore) {\n    return function(input) {\n        var result = rule(input);\n        if (result.isSuccess()) {\n            var mainRule = exports.sequence.capture(rule, \"main\");\n            var remainingRule = zeroOrMore(exports.then(\n                exports.sequence(separator, mainRule),\n                exports.sequence.extract(mainRule)\n            ));\n            var remainingResult = remainingRule(result.remaining());\n            return results.success([result.value()].concat(remainingResult.value()), remainingResult.remaining());\n        } else if (isOneOrMore || result.isError()) {\n            return result;\n        } else {\n            return results.success([], input);\n        }\n    };\n};\n\nexports.leftAssociative = function(leftRule, rightRule, func) {\n    var rights;\n    if (func) {\n        rights = [{func: func, rule: rightRule}];\n    } else {\n        rights = rightRule;\n    }\n    rights = rights.map(function(right) {\n        return exports.then(right.rule, function(rightValue) {\n            return function(leftValue, source) {\n                return right.func(leftValue, rightValue, source);\n            };\n        });\n    });\n    var repeatedRule = exports.firstOf.apply(null, [\"rules\"].concat(rights));\n    \n    return function(input) {\n        var start = input;\n        var leftResult = leftRule(input);\n        if (!leftResult.isSuccess()) {\n            return leftResult;\n        }\n        var repeatedResult = repeatedRule(leftResult.remaining());\n        while (repeatedResult.isSuccess()) {\n            var remaining = repeatedResult.remaining();\n            var source = start.to(repeatedResult.remaining());\n            var right = repeatedResult.value();\n            leftResult = results.success(\n                right(leftResult.value(), source),\n                remaining,\n                source\n            );\n            repeatedResult = repeatedRule(leftResult.remaining());\n        }\n        if (repeatedResult.isError()) {\n            return repeatedResult;\n        }\n        return leftResult;\n    };\n};\n\nexports.leftAssociative.firstOf = function() {\n    return Array.prototype.slice.call(arguments, 0);\n};\n\nexports.nonConsuming = function(rule) {\n    return function(input) {\n        return rule(input).changeRemaining(input);\n    };\n};\n\nvar describeToken = function(token) {\n    if (token.value) {\n        return token.name + \" \\\"\" + token.value + \"\\\"\";\n    } else {\n        return token.name;\n    }\n};\n\nfunction describeTokenMismatch(input, expected) {\n    var error;\n    var token = input.head();\n    if (token) {\n        error = errors.error({\n            expected: expected,\n            actual: describeToken(token),\n            location: token.source\n        });\n    } else {\n        error = errors.error({\n            expected: expected,\n            actual: \"end of tokens\"\n        });\n    }\n    return results.failure([error], input);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}