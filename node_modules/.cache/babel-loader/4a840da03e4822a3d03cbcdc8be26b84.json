{"ast":null,"code":"import getLength from './_getLength.js';\nimport { slice } from './_setup.js';\nimport isNaN from './isNaN.js'; // Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.\n\nexport default function createIndexFinder(dir, predicateFind, sortedIndex) {\n  return function (array, item, idx) {\n    var i = 0,\n        length = getLength(array);\n\n    if (typeof idx == 'number') {\n      if (dir > 0) {\n        i = idx >= 0 ? idx : Math.max(idx + length, i);\n      } else {\n        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n      }\n    } else if (sortedIndex && idx && length) {\n      idx = sortedIndex(array, item);\n      return array[idx] === item ? idx : -1;\n    }\n\n    if (item !== item) {\n      idx = predicateFind(slice.call(array, i, length), isNaN);\n      return idx >= 0 ? idx + i : -1;\n    }\n\n    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n      if (array[idx] === item) return idx;\n    }\n\n    return -1;\n  };\n}","map":{"version":3,"names":["getLength","slice","isNaN","createIndexFinder","dir","predicateFind","sortedIndex","array","item","idx","i","length","Math","max","min","call"],"sources":["E:/react-projects/new project/2022/converter/converter/node_modules/underscore/modules/_createIndexFinder.js"],"sourcesContent":["import getLength from './_getLength.js';\nimport { slice } from './_setup.js';\nimport isNaN from './isNaN.js';\n\n// Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.\nexport default function createIndexFinder(dir, predicateFind, sortedIndex) {\n  return function(array, item, idx) {\n    var i = 0, length = getLength(array);\n    if (typeof idx == 'number') {\n      if (dir > 0) {\n        i = idx >= 0 ? idx : Math.max(idx + length, i);\n      } else {\n        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n      }\n    } else if (sortedIndex && idx && length) {\n      idx = sortedIndex(array, item);\n      return array[idx] === item ? idx : -1;\n    }\n    if (item !== item) {\n      idx = predicateFind(slice.call(array, i, length), isNaN);\n      return idx >= 0 ? idx + i : -1;\n    }\n    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n      if (array[idx] === item) return idx;\n    }\n    return -1;\n  };\n}\n"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,iBAAtB;AACA,SAASC,KAAT,QAAsB,aAAtB;AACA,OAAOC,KAAP,MAAkB,YAAlB,C,CAEA;;AACA,eAAe,SAASC,iBAAT,CAA2BC,GAA3B,EAAgCC,aAAhC,EAA+CC,WAA/C,EAA4D;EACzE,OAAO,UAASC,KAAT,EAAgBC,IAAhB,EAAsBC,GAAtB,EAA2B;IAChC,IAAIC,CAAC,GAAG,CAAR;IAAA,IAAWC,MAAM,GAAGX,SAAS,CAACO,KAAD,CAA7B;;IACA,IAAI,OAAOE,GAAP,IAAc,QAAlB,EAA4B;MAC1B,IAAIL,GAAG,GAAG,CAAV,EAAa;QACXM,CAAC,GAAGD,GAAG,IAAI,CAAP,GAAWA,GAAX,GAAiBG,IAAI,CAACC,GAAL,CAASJ,GAAG,GAAGE,MAAf,EAAuBD,CAAvB,CAArB;MACD,CAFD,MAEO;QACLC,MAAM,GAAGF,GAAG,IAAI,CAAP,GAAWG,IAAI,CAACE,GAAL,CAASL,GAAG,GAAG,CAAf,EAAkBE,MAAlB,CAAX,GAAuCF,GAAG,GAAGE,MAAN,GAAe,CAA/D;MACD;IACF,CAND,MAMO,IAAIL,WAAW,IAAIG,GAAf,IAAsBE,MAA1B,EAAkC;MACvCF,GAAG,GAAGH,WAAW,CAACC,KAAD,EAAQC,IAAR,CAAjB;MACA,OAAOD,KAAK,CAACE,GAAD,CAAL,KAAeD,IAAf,GAAsBC,GAAtB,GAA4B,CAAC,CAApC;IACD;;IACD,IAAID,IAAI,KAAKA,IAAb,EAAmB;MACjBC,GAAG,GAAGJ,aAAa,CAACJ,KAAK,CAACc,IAAN,CAAWR,KAAX,EAAkBG,CAAlB,EAAqBC,MAArB,CAAD,EAA+BT,KAA/B,CAAnB;MACA,OAAOO,GAAG,IAAI,CAAP,GAAWA,GAAG,GAAGC,CAAjB,GAAqB,CAAC,CAA7B;IACD;;IACD,KAAKD,GAAG,GAAGL,GAAG,GAAG,CAAN,GAAUM,CAAV,GAAcC,MAAM,GAAG,CAAlC,EAAqCF,GAAG,IAAI,CAAP,IAAYA,GAAG,GAAGE,MAAvD,EAA+DF,GAAG,IAAIL,GAAtE,EAA2E;MACzE,IAAIG,KAAK,CAACE,GAAD,CAAL,KAAeD,IAAnB,EAAyB,OAAOC,GAAP;IAC1B;;IACD,OAAO,CAAC,CAAR;EACD,CApBD;AAqBD"},"metadata":{},"sourceType":"module"}